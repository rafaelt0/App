import streamlit as st
import yfinance as yf
import matplotlib.pyplot as plt
import numpy as np
import fundamentus
import pandas as pd
import seaborn as sns
import warnings
import pypfopt
from pypfopt.expected_returns import mean_historical_return
from pypfopt.risk_models import CovarianceShrinkage
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import objective_functions
import datetime
from scipy.stats import kurtosis, skew
from pypfopt import plotting
import re

warnings.filterwarnings('ignore')
plt.style.use('ggplot')

# Fun√ß√£o para limpar colunas num√©ricas que podem ter caracteres indesejados
def clean_numeric_column(col):
    col = col.astype(str).str.strip()
    col = col.str.replace(r'[^0-9,.\-]', '', regex=True)  # remove tudo que n√£o for n√∫mero, v√≠rgula, ponto, menos
    col = col.str.replace(',', '.')
    return pd.to_numeric(col, errors='coerce')

# Configura√ß√µes da p√°gina
st.set_page_config(
    page_title="An√°lise de A√ß√µes B3",
    page_icon="üìà",
    layout="wide"
)
st.sidebar.success("Selecione uma p√°gina")

with open("style.css") as f:
    st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)

st.title("**B3 Explorer üìà**")

# Carregando as a√ß√µes com setor
data = pd.read_csv('acoes-listadas-b3.csv')

if 'Setor' not in data.columns:
    st.error("O arquivo CSV precisa conter a coluna 'Setor' para o filtro funcionar.")
    st.stop()

stocks = list(data['Ticker'].values)

setores = sorted(data['Setor'].dropna().unique())

# Filtro de setor via dropdown (selectbox)
setor_selecionado = st.sidebar.selectbox('Escolha um Setor', setores)

tickers_filtrados = data[data['Setor'] == setor_selecionado]['Ticker'].tolist()

st.subheader("Explore a√ß√µes da B3 üß≠")
tickers = st.multiselect('Escolha a√ß√µes para explorar! (2 ou mais a√ß√µes)', tickers_filtrados)

if tickers:
    try:
        df = pd.concat([fundamentus.get_papel(t) for t in tickers])
        df['PL'] = clean_numeric_column(df['PL'])  # PL tratado

        st.subheader("Setor")
        st.write(df[['Empresa', 'Setor', 'Subsetor']].drop_duplicates(keep='last'))

        st.subheader("Informa√ß√µes de Mercado")
        df_price = df[['Cotacao', 'Min_52_sem', 'Max_52_sem', 'Vol_med_2m', 
                       'Valor_de_mercado', 'Data_ult_cot']]
        df_price.columns = ["Cota√ß√£o", "M√≠nimo (52 semanas)", "M√°ximo (52 semanas)",
                            "Volume M√©dio (2 meses)", "Valor de Mercado", "Data √öltima Cota√ß√£o"]

        for col in ["Cota√ß√£o", "M√≠nimo (52 semanas)", "M√°ximo (52 semanas)", 
                    "Volume M√©dio (2 meses)", "Valor de Mercado"]:
            df_price[col] = clean_numeric_column(df_price[col]).fillna(0)

        format_dict = {
            "Cota√ß√£o": "R$ {:,.2f}",
            "M√≠nimo (52 semanas)": "R$ {:,.2f}",
            "M√°ximo (52 semanas)": "R$ {:,.2f}",
            "Volume M√©dio (2 meses)": "{:,.0f}",
            "Valor de Mercado": "R$ {:,.0f}"
        }

        st.dataframe(df_price.style.format(format_dict), use_container_width=True)

        st.subheader("Indicadores Financeiros")
        df_ind = df[['Marg_Liquida','Marg_EBIT','ROE','ROIC','Div_Yield',
                     'Cres_Rec_5a','PL','EV_EBITDA']].drop_duplicates(keep='last')
        df_ind.columns = ["Margem L√≠quida", "Margem EBIT", "ROE", "ROIC",
                          "Dividend Yield", "Crescimento Receita 5 anos", "P/L", "EV/EBITDA"]

        for col in df_ind.columns:
            df_ind[col] = clean_numeric_column(df_ind[col])

        pct_cols = ["Margem L√≠quida", "Margem EBIT", "ROE", "ROIC", "Dividend Yield", "Crescimento Receita 5 anos"]
        for col in pct_cols:
            df_ind[col] = df_ind[col] * 100

        df_ind = df_ind.fillna(0)

        format_ind = {
            "Margem L√≠quida": "{:.2f}%",
            "Margem EBIT": "{:.2f}%",
            "ROE": "{:.2f}%",
            "ROIC": "{:.2f}%",
            "Dividend Yield": "{:.2f}%",
            "Crescimento Receita 5 anos": "{:.2f}%",
            "P/L": "{:.2f}",
            "EV/EBITDA": "{:.2f}"
        }

        st.dataframe(df_ind.style.format(format_ind), use_container_width=True)

        tickers_yf = [t + ".SA" for t in tickers]
        data_inicio = st.sidebar.date_input("Data Inicial üìÖ", datetime.date(2025,1,1),
                                            min_value=datetime.date(2000,1,1),
                                            max_value=datetime.date.today())
        
        st.sidebar.header('Configura√ß√µes ‚öôÔ∏è')
        interval_selected = st.sidebar.selectbox('Intervalo üìä', 
                                                 ['1d','1wk','1mo','3mo','6mo','1y'])
        
        data_prices = yf.download(tickers_yf, start=data_inicio, end=datetime.datetime.now(), 
                                  interval=interval_selected)['Close']
        
        if isinstance(data_prices.columns, pd.MultiIndex):
            data_prices = data_prices.droplevel(0, axis=1)

        st.subheader("Cota√ß√£o Hist√≥rica")
        st.line_chart(data_prices)

        returns = data_prices.pct_change().dropna() * 100
        returns_pct = returns.round(2).astype(str) + '%'
        st.subheader("Retornos (%)")
        st.dataframe(returns_pct)

        descriptions = []
        for t in tickers_yf:
            try:
                info = yf.Ticker(t).get_info()
                descriptions.append(info.get('longBusinessSummary', 'N√£o dispon√≠vel'))
            except:
                descriptions.append('N√£o dispon√≠vel')

        df_desc = pd.DataFrame(descriptions, index=tickers, columns=["Descri√ß√£o"])
        st.subheader("Descri√ß√£o da Empresa")
        st.table(df_desc)

    except Exception as e:
        st.error(f"Erro ao buscar dados: {e}")
else:
    st.info("Selecione pelo menos uma a√ß√£o para iniciar a an√°lise.")



